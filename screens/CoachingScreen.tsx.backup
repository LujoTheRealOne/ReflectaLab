import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { StyleSheet, Text, TextInput, View, useColorScheme, TouchableOpacity, ScrollView, SafeAreaView, KeyboardAvoidingView, Platform, Keyboard, ColorSchemeName, Animated, RefreshControl } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Mic, X, Check, ArrowUp, ArrowDown } from 'lucide-react-native';
import * as Crypto from 'expo-crypto';
import { Colors } from '@/constants/Colors';
import { AppStackParamList } from '@/navigation/AppNavigator';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Button } from '@/components/ui/Button';
import { useAICoaching, CoachingMessage } from '@/hooks/useAICoaching';
import { useCoachingSession } from '@/hooks/useCoachingSession';
import { useAuth } from '@/hooks/useAuth';
import { useAnalytics } from '@/hooks/useAnalytics';
import { useAudioTranscription } from '@/hooks/useAudioTranscription';
import { activateKeepAwakeAsync, deactivateKeepAwake } from 'expo-keep-awake';
import { ActionPlanCard, BlockersCard, FocusCard, MeditationCard } from '@/components/cards';
import { useRevenueCat } from '@/hooks/useRevenueCat';
import { Alert } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { db } from '@/lib/firebase';
import { doc, setDoc, serverTimestamp } from 'firebase/firestore';

type CoachingScreenNavigationProp = NativeStackNavigationProp<AppStackParamList, 'SwipeableScreens'>;

// Spinning animation component
const SpinningAnimation = ({ colorScheme }: { colorScheme: ColorSchemeName }) => {
  const spinValue = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    const spinAnimation = Animated.loop(
      Animated.timing(spinValue, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true
      })
    );
    
    spinAnimation.start();
    
    return () => {
      spinAnimation.stop();
    };
  }, [spinValue]);
  
  const spin = spinValue.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg']
  });
  
  return (
    <View style={styles.loadingSpinner}>
      <Animated.View 
        style={[
          styles.spinner,
          { 
            backgroundColor: colorScheme === 'dark' ? '#666666' : '#333333',
            transform: [{ rotate: spin }]
          }
        ]}
      />
    </View>
  );
};

// Animated typing indicator component
const AnimatedTypingIndicator = ({ colorScheme }: { colorScheme: ColorSchemeName }) => {
  const dot1Animation = useRef(new Animated.Value(0)).current;
  const dot2Animation = useRef(new Animated.Value(0)).current;
  const dot3Animation = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    // Create individual animations for each dot
    const animation1 = Animated.loop(
      Animated.sequence([
        Animated.timing(dot1Animation, {
          toValue: 1,
          duration: 600,
          useNativeDriver: true
        }),
        Animated.timing(dot1Animation, {
          toValue: 0,
          duration: 600,
          useNativeDriver: true
        })
      ])
    );

    const animation2 = Animated.loop(
      Animated.sequence([
        Animated.timing(dot2Animation, {
          toValue: 1,
          duration: 600,
          delay: 200,
          useNativeDriver: true
        }),
        Animated.timing(dot2Animation, {
          toValue: 0,
          duration: 600,
          useNativeDriver: true
        })
      ])
    );

    const animation3 = Animated.loop(
      Animated.sequence([
        Animated.timing(dot3Animation, {
          toValue: 1,
          duration: 600,
          delay: 400,
          useNativeDriver: true
        }),
        Animated.timing(dot3Animation, {
          toValue: 0,
          duration: 600,
          useNativeDriver: true
        })
      ])
    );

    animation1.start();
    animation2.start();
    animation3.start();

    return () => {
      animation1.stop();
      animation2.stop();
      animation3.stop();
    };
  }, [dot1Animation, dot2Animation, dot3Animation]);

  const dot1Opacity = dot1Animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0.3, 1]
  });

  const dot2Opacity = dot2Animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0.3, 1]
  });

  const dot3Opacity = dot3Animation.interpolate({
    inputRange: [0, 1],
    outputRange: [0.3, 1]
  });

  return (
    <View style={styles.typingIndicator}>
      <Animated.View 
        style={[
          styles.typingDot, 
          { 
            backgroundColor: colorScheme === 'dark' ? '#888888' : '#333333',
            opacity: dot1Opacity
          }
        ]} 
      />
      <Animated.View 
        style={[
          styles.typingDot, 
          { 
            backgroundColor: colorScheme === 'dark' ? '#888888' : '#333333',
            opacity: dot2Opacity
          }
        ]} 
      />
      <Animated.View 
        style={[
          styles.typingDot, 
          { 
            backgroundColor: colorScheme === 'dark' ? '#888888' : '#333333',
            opacity: dot3Opacity
          }
        ]} 
      />
    </View>
  );
};

// Audio level indicator component
const AudioLevelIndicator = ({ audioLevel, colorScheme }: { audioLevel: number, colorScheme: ColorSchemeName }) => {
  const totalDots = 6;
  
  const isDotActive = (index: number) => {
    const threshold = (index + 1) / totalDots;
    return audioLevel >= threshold;
  };
  
  return (
    <View style={styles.audioLevelContainer}>
      {Array.from({ length: totalDots }).map((_, index) => {
        const isActive = isDotActive(index);
        
        return (
          <View 
            key={index}
                          style={[
                styles.audioLevelDot, 
                { 
                  backgroundColor: isActive
                    ? (colorScheme === 'dark' ? '#888888' : '#111111')
                    : (colorScheme === 'dark' ? '#444444' : '#E5E5E5')
                }
              ]}
          />
        );
      })}
    </View>
  );
};

// Recording timer component
const RecordingTimer = ({ startTime, colorScheme }: { startTime: Date | null, colorScheme: ColorSchemeName }) => {
  const [elapsed, setElapsed] = useState('00:00');
  
  useEffect(() => {
    if (!startTime) return;
    
    const interval = setInterval(() => {
      const now = new Date();
      const diffMs = now.getTime() - startTime.getTime();
      const diffSec = Math.floor(diffMs / 1000);
      const minutes = Math.floor(diffSec / 60).toString().padStart(2, '0');
      const seconds = (diffSec % 60).toString().padStart(2, '0');
      setElapsed(`${minutes}:${seconds}`);
    }, 1000);
    
    return () => clearInterval(interval);
  }, [startTime]);
  
  return (
    <Text style={[styles.recordingTimer, { color: colorScheme === 'dark' ? '#FFFFFF' : '#333333' }]}>
      {elapsed}
    </Text>
  );
};

export default function CoachingScreen() {
  const navigation = useNavigation<CoachingScreenNavigationProp>();
  const route = useRoute();
  const colorScheme = useColorScheme();
  const colors = Colors[colorScheme ?? 'light'];
  const insets = useSafeAreaInsets();
  const { user, firebaseUser, getToken } = useAuth();
  const { 
    trackCoachingSessionStarted, 
    trackCoachingSessionCompleted,
    trackEntryCreated
  } = useAnalytics();
  const { isPro, presentPaywallIfNeeded, currentOffering, initialized } = useRevenueCat(firebaseUser?.uid);

  // Get route parameters for breakout session
  const routeSessionId = (route.params as any)?.sessionId;
  const routeSessionType = (route.params as any)?.sessionType;
  const isBreakoutSession = !!routeSessionId; // If sessionId is provided, it's a breakout session

  // Session ID logic: Main session = user.uid, Breakout session = provided sessionId
  const getSessionId = (): string | null => {
    if (isBreakoutSession) {
      return routeSessionId; // Breakout session ID from route
    } else {
      return user?.id || null; // Main session = user ID (endless chat)
    }
  };

  const currentSessionId = getSessionId();
  const [loadingExistingSession, setLoadingExistingSession] = useState(false);

  // Use the AI coaching hook for message handling
  const { messages: localMessages, isLoading, isStreaming, sendMessage, setMessages: setLocalMessages, progress } = useAICoaching();
  
  // Use the coaching session hook for real-time session data
  const { 
    session: loadedSession, 
    loading: isLoadingSession, 
    error: sessionError,
    loadMoreMessages,
    hasMoreMessages,
    isLoadingMore
  } = useCoachingSession(currentSessionId);
  
  const [chatInput, setChatInput] = useState('');
  const [isChatInputFocused, setIsChatInputFocused] = useState(false);
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const [inputHeight, setInputHeight] = useState(24); // Initial height for minimum 1 line
  const [containerHeight, setContainerHeight] = useState(90); // Dynamic container height
  const [isInputExpanded, setIsInputExpanded] = useState(false); // Expand durumu
  const [currentLineCount, setCurrentLineCount] = useState(1); // Current line count
  const [showCompletionForMessage, setShowCompletionForMessage] = useState<string | null>(null);
  const [sessionStartTime] = useState(new Date());
  const [completionStats, setCompletionStats] = useState({
    minutes: 0,
    words: 0,
    keyInsights: 0
  });
  
  // Starting state management
  const [showingStartingState, setShowingStartingState] = useState(false);
  const [startingStateMessage, setStartingStateMessage] = useState<CoachingMessage | null>(null);
  
  // Helper: build a normalization key to dedupe messages between Firestore and local
  const buildMessageKey = useCallback((message: CoachingMessage): string => {
    const normalizedContent = message.content
      .replace(/\s+/g, ' ') // collapse multiple spaces/newlines
      .trim()
      .toLowerCase();
    return `${message.role}|${normalizedContent}`;
  }, []);

  // Combine Firestore messages with local messages and starting state
  const allMessages = useMemo(() => {
    const firestoreMessages = loadedSession?.messages || [];
    const firestoreKeys = new Set(firestoreMessages.map(buildMessageKey));

    // Only keep optimistic locals that are not yet present in Firestore (by role+normalized content)
    const optimisticLocals = localMessages.filter((m) => !firestoreKeys.has(buildMessageKey(m)));

    const combinedMessages: CoachingMessage[] = [
      ...firestoreMessages,
      ...optimisticLocals,
      ...(showingStartingState && startingStateMessage ? [startingStateMessage] : [])
    ];

    // Sort by timestamp (oldest -> newest)
    const sorted = combinedMessages.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());

    // Tail de-duplication to avoid double-render during streaming:
    // After the last user message, there should be at most one assistant reply.
    // If multiple assistant messages exist (e.g., Firestore + local placeholder), keep the one with longer content.
    let lastUserIndex = -1;
    for (let i = sorted.length - 1; i >= 0; i -= 1) {
      if (sorted[i].role === 'user') { lastUserIndex = i; break; }
    }

    const head = sorted.slice(0, lastUserIndex + 1);
    const tail = sorted.slice(lastUserIndex + 1);

    if (tail.length > 1 && tail.every(m => m.role === 'assistant')) {
      // During streaming, prefer the shorter (partial) assistant content to avoid jumping to full Firestore text
      const preferred = tail.reduce((acc, m) => (m.content.length < acc.content.length ? m : acc), tail[0]);
      return [...head, preferred];
    }

    return sorted;
  }, [loadedSession?.messages, localMessages, showingStartingState, startingStateMessage, buildMessageKey]);

  // Clear local messages that are now present in Firestore (content-level dedupe)
  // But don't clear during streaming to avoid interrupting typewriter effect
  useEffect(() => {
    if (loadedSession && localMessages.length > 0 && !isStreaming) {
      const firestoreKeys = new Set(loadedSession.messages.map(buildMessageKey));

      const remainingLocals = localMessages.filter((m) => !firestoreKeys.has(buildMessageKey(m)));
      const removedCount = localMessages.length - remainingLocals.length;

      if (removedCount > 0) {
        console.log(`🧹 Clearing ${removedCount} local messages that are now in Firestore (by content)`);
        setLocalMessages(remainingLocals);
      }
    }
  }, [loadedSession, localMessages, buildMessageKey, setLocalMessages, isStreaming]);

  // Handle starting state when session loads
  useEffect(() => {
    if (loadedSession && !isBreakoutSession) {
      const sessionMessages = loadedSession.messages;
      
      if (sessionMessages.length > 0 && isLastMessageOld(sessionMessages)) {
        const startingMessage = generateStartingStateMessage(sessionMessages);
        setStartingStateMessage(startingMessage);
        setShowingStartingState(true);
        console.log('📌 Showing starting state message - last message is 2+ hours old');
      } else {
        setShowingStartingState(false);
        setStartingStateMessage(null);
      }
    }
  }, [loadedSession, isBreakoutSession]);
  const [parsedCoachingData, setParsedCoachingData] = useState<{
    components: Array<{ type: string; props: Record<string, string> }>;
    rawData: string;
  } | null>(null);

  // Enhanced loading state management
  const [showLoadingIndicator, setShowLoadingIndicator] = useState(false);

  // Track AI response state more reliably
  const [aiResponseStarted, setAiResponseStarted] = useState(false);

  // Track when AI response actually starts
  useEffect(() => {
    if (isLoading) {
      setShowLoadingIndicator(true);
    } else {
      // Add a small delay before hiding loading indicator to ensure AI response is visible
      const timer = setTimeout(() => {
        setShowLoadingIndicator(false);
      }, 500); // 500ms delay to ensure AI response is rendered
      
      return () => clearTimeout(timer);
    }
  }, [isLoading]);

  // Monitor when AI response actually starts
  useEffect(() => {
    if (allMessages.length > 0) {
      const lastMessage = allMessages[allMessages.length - 1];
      const isLastMessageAI = lastMessage?.role === 'assistant';
      
      if (isLastMessageAI && isLoading) {
        // AI response has started
        setAiResponseStarted(true);
      } else if (!isLoading && aiResponseStarted) {
        // AI response has completed
        setAiResponseStarted(false);
      }
    }
  }, [allMessages, isLoading, aiResponseStarted]);

  // Enhanced loading indicator logic
  const shouldShowLoadingIndicator = isLoading || (aiResponseStarted && allMessages.length > 0);

  //POWERFUL MESSAGE POSITIONING SYSTEM

  // 1. Define constant values
  const HEADER_HEIGHT = 120;
  const INPUT_HEIGHT = 160;
  const MESSAGE_TARGET_OFFSET = 20; // How many pixels below the header
  
  // Dynamic input constants
  const LINE_HEIGHT = 24;
  const MIN_LINES = 1;
  const MAX_LINES = 10;
  const EXPANDED_MAX_LINES = 40; // Expand edilmiş durumda maksimum satır
  const INPUT_PADDING_VERTICAL = 8;
  const CONTAINER_BASE_HEIGHT = 90; // Minimum container yüksekliği
  const CONTAINER_PADDING = 40; // Container'daki padding toplamı (8+20+12)

  // Dynamic content height calculation
  const dynamicContentHeight = useMemo(() => {
    let totalHeight = 12; // paddingTop
    
    allMessages.forEach((message, index) => {
      const contentLength = message.content.length;
      const lines = Math.max(1, Math.ceil(contentLength / 44));
      let messageHeight = lines * 22 + 32;
      
      if (message.role === 'assistant') {
        const isLastMessage = index === allMessages.length - 1;
        const isCurrentlyStreaming = isLastMessage && isLoading;
        
        if (isCurrentlyStreaming) {
          messageHeight += 200;
        } else {
          messageHeight += 80;
        }
      }
      
      totalHeight += messageHeight + 16;
    });
    
    // Add loading indicator height
    if (shouldShowLoadingIndicator) {
      totalHeight += 60;
    }
    
    return totalHeight;
  }, [allMessages, isLoading, shouldShowLoadingIndicator]);

  // 2. Dynamic bottom padding - account for live input container height so last lines stay visible
  const dynamicBottomPadding = useMemo(() => {
    // Base padding when idle
    const basePadding = 50;

    // Klavye açıksa ekstra alan ekle
    const keyboardExtraSpace = keyboardHeight > 0 ? keyboardHeight + containerHeight + 20 : 80;

    // Extra space for the growing input container to prevent overlap
    const extraForInput = Math.max(0, containerHeight - CONTAINER_BASE_HEIGHT) + 40; // small cushion

    // If the AI is responding or user just sent a message, add more for positioning
    const lastMessage = allMessages[allMessages.length - 1];
    const isUserWaitingForAI = lastMessage?.role === 'user' || isLoading;
    
    if (keyboardHeight > 0) {
      // Klavye açıkken - daha fazla alan ver
      return keyboardExtraSpace;
    } else if (isUserWaitingForAI) {
      return basePadding + extraForInput + 120;
    }

    return basePadding + extraForInput;
  }, [allMessages, isLoading, containerHeight, keyboardHeight]);

  // New state for content height tracking
  const [contentHeight, setContentHeight] = useState(0);
  const [scrollViewHeight, setScrollViewHeight] = useState(0);

  // Scroll limits calculation - simplified
  const scrollLimits = useMemo(() => {
    const minContentHeight = dynamicContentHeight + dynamicBottomPadding;
    const maxScrollDistance = Math.max(0, minContentHeight - (scrollViewHeight || 500) + 50);
    
    return {
      minContentHeight,
      maxScrollDistance
    };
  }, [dynamicContentHeight, dynamicBottomPadding, scrollViewHeight]);

  // Enhanced scroll position tracking for scroll-to-bottom button
  const [showScrollToBottom, setShowScrollToBottom] = useState(false);

  // Function to parse coaching completion data between finish tokens
  const parseCoachingCompletion = (content: string) => {
    const finishStartIndex = content.indexOf('[finish-start]');
    const finishEndIndex = content.indexOf('[finish-end]');
    
    if (finishStartIndex === -1 || finishEndIndex === -1) {
      return { components: [], rawData: '' };
    }
    
    // Extract content between finish tokens
    const finishContent = content.slice(finishStartIndex + '[finish-start]'.length, finishEndIndex).trim();
    
    // Parse component markers like [focus:focus="...",context="..."]
    const componentRegex = /\[(\w+):([^\]]+)\]/g;
    const components: Array<{ type: string; props: Record<string, string> }> = [];
    
    let match;
    while ((match = componentRegex.exec(finishContent)) !== null) {
      const componentType = match[1];
      const propsString = match[2];
      
      // Parse props from key="value" format
      const props: Record<string, string> = {};
      const propRegex = /(\w+)="([^"]+)"/g;
      let propMatch;
      
      while ((propMatch = propRegex.exec(propsString)) !== null) {
        const [, key, value] = propMatch;
        props[key] = value;
      }
      
      components.push({ type: componentType, props });
    }
    
    console.log('🎯 Parsed coaching completion:', { 
      componentsCount: components.length, 
      components,
      rawFinishContent: finishContent
    });
    
    return { components, rawData: finishContent };
  };

  // Function to parse coaching cards from any content
  const parseCoachingCards = (content: string) => {
    // Parse component markers like [focus:focus="...",context="..."]
    const componentRegex = /\[(\w+):([^\]]+)\]/g;
    const components: Array<{ type: string; props: Record<string, string> }> = [];
    
    let match;
    while ((match = componentRegex.exec(content)) !== null) {
      const componentType = match[1];
      const propsString = match[2];
      
      // Parse props from key="value" format
      const props: Record<string, string> = {};
      const propRegex = /(\w+)="([^"]+)"/g;
      let propMatch;
      
      while ((propMatch = propRegex.exec(propsString)) !== null) {
        const [, key, value] = propMatch;
        props[key] = value;
      }
      
      components.push({ type: componentType, props });
    }
    
    return components;
  };

  // Starting state logic - check if last message is older than 2 hours
  const isLastMessageOld = (messages: CoachingMessage[]): boolean => {
    if (allMessages.length === 0) return true;
    
    const lastMessage = allMessages[allMessages.length - 1];
    const now = new Date();
    const hoursDiff = (now.getTime() - lastMessage.timestamp.getTime()) / (1000 * 60 * 60);
    
    return hoursDiff > 2; // 2+ hours old
  };

  // Generate starting state message
  const generateStartingStateMessage = (messages: CoachingMessage[]): CoachingMessage => {
    // Check if last assistant message has insight cards
    const lastAssistantMessage = [...messages].reverse().find(msg => msg.role === 'assistant');
    
    if (lastAssistantMessage && hasInsightCards(lastAssistantMessage.content)) {
      // Re-show the last insight card message
      return {
        id: `starting-state-${Date.now()}`,
        role: 'assistant',
        content: lastAssistantMessage.content,
        timestamp: new Date()
      };
    }
    
    // Default welcome back message
    return {
      id: `starting-state-${Date.now()}`,
      role: 'assistant', 
      content: "Welcome back! I'm here to support you in exploring what's on your mind.\n\nWhat would you like to focus on today?",
      timestamp: new Date()
    };
  };

  // Check if message has insight cards
  const hasInsightCards = (content: string): boolean => {
    const cardTypes = ['focus:', 'blockers:', 'meditation:', 'actionplan:'];
    return cardTypes.some(type => content.includes(`[${type}`));
  };

  // Function to render a coaching card based on type and props
  const renderCoachingCard = (type: string, props: Record<string, string>, index: number) => {
    const baseProps = {
      key: `coaching-card-${type}-${index}`,
      editable: false, // Cards in messages should not be editable
    };

    switch (type) {
      case 'meditation':
        return (
          <MeditationCard
            {...baseProps}
            title={props.title || 'Guided Meditation'}
            duration={parseInt(props.duration || '300')}
            description={props.description}
            type={(props.type as 'breathing' | 'mindfulness' | 'body-scan') || 'breathing'}
          />
        );
      case 'focus':
        // Handle both expected format (focus/context) and AI output format (headline/explanation)
        const focusText = props.focus || props.headline || 'Main focus not specified';
        const contextText = props.context || props.explanation;
        
        return (
          <FocusCard
            {...baseProps}
            focus={focusText}
            context={contextText}
          />
        );
      case 'blockers':
        const blockers = props.items ? props.items.split('|').map((item: string) => item.trim()).filter(Boolean) : [];
        return (
          <BlockersCard
            {...baseProps}
            blockers={blockers}
            title={props.title}
          />
        );
      case 'actions':
        const actions = props.items ? props.items.split('|').map((item: string) => item.trim()).filter(Boolean) : [];
        return (
          <ActionPlanCard
            {...baseProps}
            actions={actions}
            title={props.title}
          />
        );
      case 'checkin':
        // Check-in cards are handled by the scheduling popup system
        return null;
      default:
        return (
          <View key={`unknown-card-${index}`} style={{
            padding: 16, 
            backgroundColor: colorScheme === 'dark' ? '#374151' : '#F3F4F6', 
            borderRadius: 8, 
            marginVertical: 8
          }}>
            <Text style={{ color: colorScheme === 'dark' ? '#9CA3AF' : '#6B7280', fontSize: 14 }}>
              Unknown component: {type}
            </Text>
          </View>
        );
    }
  };

  // Function to clean message content by removing finish tokens and coaching cards
  const getDisplayContent = (content: string) => {
    let cleanContent = content;
    
    // Remove content between finish tokens, but preserve content after [finish-end]
    const finishStartIndex = cleanContent.indexOf('[finish-start]');
    const finishEndIndex = cleanContent.indexOf('[finish-end]');
    
    if (finishStartIndex !== -1 && finishEndIndex !== -1) {
      // Keep content before [finish-start] and after [finish-end]
      const beforeFinish = cleanContent.slice(0, finishStartIndex).trim();
      const afterFinish = cleanContent.slice(finishEndIndex + '[finish-end]'.length).trim();
      cleanContent = beforeFinish + (afterFinish ? '\n\n' + afterFinish : '');
    } else if (finishStartIndex !== -1) {
      // If only [finish-start] is found, remove everything after it
      cleanContent = cleanContent.slice(0, finishStartIndex).trim();
    }
    
    // Remove coaching card syntax like [checkin:...], [focus:...], etc.
    const coachingCardRegex = /\[(\w+):[^\]]+\]/g;
    cleanContent = cleanContent.replace(coachingCardRegex, '').trim();
    
    // Clean up extra whitespace/newlines that might be left
    cleanContent = cleanContent.replace(/\n\s*\n\s*\n/g, '\n\n'); // Replace multiple newlines with double newlines
    cleanContent = cleanContent.trim();
    
    return cleanContent;
  };

  // Use the audio transcription hook
  const {
    isRecording,
    isTranscribing,
    recordingStartTime,
    audioLevel,
    startRecording,
    stopRecordingAndTranscribe,
    cancelRecording,
  } = useAudioTranscription({
    onTranscriptionComplete: (transcription) => {
      const existingText = chatInput.trim();
      const newText = existingText 
        ? `${existingText} ${transcription}` 
        : transcription;
      setChatInput(newText);
      setTimeout(() => {
        textInputRef.current?.focus();
      }, 100);
    },
    onTranscriptionError: (error) => {
      console.error('Transcription error:', error);
    },
  });

  const scrollViewRef = useRef<ScrollView>(null);
  const textInputRef = useRef<TextInput>(null);

  // Guard against duplicate loads for the same session
  const loadedSessionIdRef = useRef<string | null>(null);
  const paywallShownRef = useRef<boolean>(false);
  const accessCheckedRef = useRef<boolean>(false);
  
  // Gate access: ALL coaching requires Pro. Run once per focus, after RevenueCat initialized.
  useFocusEffect(
    useCallback(() => {
      let cancelled = false;
      const check = async () => {
        if (accessCheckedRef.current) return;
        if (!initialized) return; // wait for RC init
        accessCheckedRef.current = true;
        // Prevent multiple paywall presentations
        if (paywallShownRef.current) {
          return;
        }
        
        // console.log('🔒 Coaching access check:', { isPro, routeSessionId });
        if (!isPro) {
          // console.log('🚫 Not Pro, showing paywall');
          paywallShownRef.current = true;
          const unlocked = await presentPaywallIfNeeded('reflecta_pro', currentOffering || undefined);
          if (!unlocked && !cancelled) {
            // console.log('🔙 Paywall cancelled, going back');
            navigation.goBack();
          } else if (unlocked) {
            // console.log('✅ Pro unlocked via paywall');
            // Reset flag so future navigation works
            paywallShownRef.current = false;
          }
        } else {
          // console.log('✅ Pro user, allowing access');
        }
      };
      check();
      return () => { cancelled = true; accessCheckedRef.current = false; };
    }, [initialized, isPro, presentPaywallIfNeeded, currentOffering, navigation])
  );

  // Track session completion when user leaves the screen (only once)
  const sessionCompletedRef = useRef(false);
  const messagesRef = useRef(allMessages);
  const sessionStartRef = useRef(sessionStartTime);
  
  // Keep refs updated
  useEffect(() => {
    messagesRef.current = allMessages;
  }, [allMessages]);
  
  useFocusEffect(
    useCallback(() => {
      // Reset completion flag when entering screen
      sessionCompletedRef.current = false;
      
      // Cleanup function that runs when leaving the screen
      return () => {
        if (currentSessionId && !sessionCompletedRef.current) {
          sessionCompletedRef.current = true; // Prevent multiple calls
          
          const sessionMinutes = Math.max(Math.floor((Date.now() - sessionStartRef.current.getTime()) / (1000 * 60)), 1);
          const messageCount = messagesRef.current.length;
          const totalWords = messagesRef.current.reduce((total: number, msg: CoachingMessage) => {
            if (msg.role === 'user') {
              return total + msg.content.split(/\s+/).filter((word: string) => word.length > 0).length;
            }
            return total;
          }, 0);

          // Log coaching session completion (only once)
          console.log('✅ [COACHING] Regular coaching session completed (user left screen)', {
            sessionId: currentSessionId,
            duration: sessionMinutes,
            messageCount: messageCount,
            wordsWritten: totalWords
          });

          // Track coaching session completion
          trackCoachingSessionCompleted({
            session_id: currentSessionId,
            duration_minutes: sessionMinutes,
            message_count: messageCount,
            words_written: totalWords,
            insights_generated: 0,
            session_type: 'regular',
          });
        }
      };
    }, [currentSessionId])
  );

  // Show initial welcome message for new main sessions
  useEffect(() => {
    if (!isBreakoutSession && !isLoadingSession && !loadedSession && allMessages.length === 0) {
      setTimeout(() => {
        const initialMessage: CoachingMessage = {
          id: '1',
          content: `Hello ${user?.firstName || 'there'}!\n\nI'm here to support your growth and reflection. What's on your mind today? Feel free to share anything that's weighing on you, exciting you, or simply present in your awareness right now.`,
          role: 'assistant',
          timestamp: new Date()
        };
        setLocalMessages([initialMessage]);
      }, 1000);
    }
  }, [isBreakoutSession, isLoadingSession, loadedSession, allMessages.length, user?.firstName]);

  // Auto-scroll to position new messages below header
  const scrollToNewMessageRef = useRef(false);
  
  // Store refs for each message to measure their positions
  const messageRefs = useRef<{ [key: string]: View | null }>({});
  
  // Store the target scroll position after user message positioning
  const targetScrollPosition = useRef<number | null>(null);
  
  // Track if user has manually scrolled
  const hasUserScrolled = useRef<boolean>(false);
  
  // Track if we've done initial scroll to latest message
  const hasInitialScrolled = useRef<boolean>(false);
  
    // 3. Completely rewrite scrollToShowLastMessage:
  const scrollToShowLastMessage = useCallback(() => {
    if (!scrollViewRef.current || allMessages.length === 0) return;
    
    const lastMessage = allMessages[allMessages.length - 1];
    
    // Only position user messages
    if (lastMessage.role !== 'user') return;
    
    console.log('🎯 Positioning user message:', lastMessage.content.substring(0, 30) + '...');
    
    // Target position: MESSAGE_TARGET_OFFSET pixels below header
    const targetFromTop = MESSAGE_TARGET_OFFSET;
    
    // Get user message ref
    const lastMessageRef = messageRefs.current[lastMessage.id];
    
    if (lastMessageRef) {
      // Measure current position of the message
      setTimeout(() => {
        lastMessageRef.measureLayout(
          scrollViewRef.current as any,
          (msgX: number, msgY: number, msgWidth: number, msgHeight: number) => {
            // Target scroll position = message Y position - target position
            const targetScrollY = Math.max(0, msgY - targetFromTop);
            
            console.log('📐 Measurement:', {
              messageY: msgY,
              targetFromTop,
              targetScrollY
            });
            
            // Perform scroll
            scrollViewRef.current?.scrollTo({
              y: targetScrollY,
              animated: true
            });
            
            // Save position
            targetScrollPosition.current = targetScrollY;
            hasUserScrolled.current = false;
            
            console.log('✅ User message positioned at scroll:', targetScrollY);
          },
          () => {
            console.log('❌ Measurement failed, using estimation');
            
            // Fallback: estimate message position
            let estimatedY = 12; // paddingTop
            
            // Sum up height of all previous messages
            for (let i = 0; i < allMessages.length - 1; i++) {
              const msg = allMessages[i];
              const lines = Math.max(1, Math.ceil(msg.content.length / 40));
              const msgHeight = lines * 22 + 48; // text + padding
              estimatedY += msgHeight + 16; // marginBottom
            }
            
            // Last message Y position
            const targetScrollY = Math.max(0, estimatedY - targetFromTop);
            
            scrollViewRef.current?.scrollTo({
              y: targetScrollY,
              animated: true
            });
            
            targetScrollPosition.current = targetScrollY;
            hasUserScrolled.current = false;
          }
        );
      }, 150); // Wait for layout to stabilize
    }
  }, [allMessages]);
  
  // 4. Simplify useEffect:
  useEffect(() => {
    // Only scroll when user sends a message
    if (scrollToNewMessageRef.current && scrollViewRef.current) {
      setTimeout(() => {
        scrollToShowLastMessage();
        scrollToNewMessageRef.current = false;
      }, 100);
    }
  }, [allMessages.length, scrollToShowLastMessage]);

  // 5. Remove position maintenance during AI response - too complex
  // Instead, adjust position once when AI response starts:
  useEffect(() => {
    if (isLoading && targetScrollPosition.current !== null) {
      // Adjust position once when AI response starts
      const maintainedPosition = targetScrollPosition.current;
      
      setTimeout(() => {
        if (scrollViewRef.current && !hasUserScrolled.current) {
          scrollViewRef.current.scrollTo({
            y: maintainedPosition,
            animated: false
          });
        }
      }, 100);
    }
  }, [isLoading]);

  // Scroll to bottom function
  const handleScrollToBottom = useCallback(() => {
    if (allMessages.length > 0) {
      const lastMessage = allMessages[allMessages.length - 1];
      const lastMessageRef = messageRefs.current[lastMessage.id];
      
      if (lastMessageRef) {
        lastMessageRef.measureLayout(
          scrollViewRef.current as any,
          (x, y, width, height) => {
            // Check if it's a long AI response
            const isLongResponse = lastMessage.role === 'assistant' && lastMessage.content.length >= 200;
            
            if (isLongResponse) {
              // For long responses: scroll to the very end of the message
              const targetY = Math.max(0, y + height - 100); // Show end of message with some space
              scrollViewRef.current?.scrollTo({
                y: targetY,
                animated: true
              });
            } else {
              // For short responses: scroll to show the message with minimal space below
              const targetY = Math.max(0, y - 20); // Small offset
              scrollViewRef.current?.scrollTo({
                y: targetY,
                animated: true
              });
            }
          },
          () => {
            // Fallback: scroll to a position that shows the last message
            const estimatedPosition = Math.max(0, (allMessages.length - 1) * 80 - 30);
            scrollViewRef.current?.scrollTo({
              y: estimatedPosition,
              animated: true
            });
          }
        );
      } else {
        // Fallback: scroll to a position that shows the last message
        const estimatedPosition = Math.max(0, (allMessages.length - 1) * 80 - 30);
        scrollViewRef.current?.scrollTo({
          y: estimatedPosition,
          animated: true
        });
      }
    } else {
      scrollViewRef.current?.scrollToEnd({ animated: true });
    }
  }, [allMessages]);

  // Auto-scroll to bottom when session loads for the first time
  useEffect(() => {
    if (loadedSession && allMessages.length > 0 && !hasInitialScrolled.current && !isLoadingSession) {
      console.log('🎯 Auto-triggering scroll to bottom on session load');
      
      setTimeout(() => {
        handleScrollToBottom();
        hasInitialScrolled.current = true;
        console.log('✅ Auto scroll to bottom completed');
      }, 500); // Delay to ensure layout and message refs are ready
    }
  }, [loadedSession, allMessages.length, isLoadingSession, handleScrollToBottom]);

  // Reset initial scroll flag when session changes
  useEffect(() => {
    hasInitialScrolled.current = false;
  }, [currentSessionId]);

  // 6. Clear when progress reaches 100%:
  useEffect(() => {
    if (progress === 100) {
      setTimeout(() => {
        targetScrollPosition.current = null;
        hasUserScrolled.current = false;
        console.log('🧹 Positioning cleared after AI response');
      }, 1000);
    }
  }, [progress]);

  // Check for completion when progress reaches 100%
  useEffect(() => {
    if (progress === 100 && !showCompletionForMessage) {
      console.log('🎯 Progress reached 100%! Showing completion popup...');
      
      // Find the final AI message
      const lastAIMessage = [...allMessages].reverse().find(msg => msg.role === 'assistant');
      
      if (lastAIMessage) {
        // Calculate session statistics
        const sessionEndTime = new Date();
        const sessionDurationMs = sessionEndTime.getTime() - sessionStartTime.getTime();
        const sessionMinutes = Math.round(sessionDurationMs / 60000);
        
        // Count words from user messages
        const userMessages = allMessages.filter(msg => msg.role === 'user');
        const totalWords = userMessages.reduce((count, msg) => {
          return count + msg.content.trim().split(/\s+/).filter(word => word.length > 0).length;
        }, 0);

        // Parse coaching completion data if available
        const parsedData = parseCoachingCompletion(lastAIMessage.content);
        const keyInsights = Math.max(parsedData.components.length, 3); // Use actual parsed components count
        
        setCompletionStats({
          minutes: Math.max(sessionMinutes, 1),
          words: totalWords,
          keyInsights
        });
        
        // Store parsed coaching data for future use
        setParsedCoachingData(parsedData);
        
        // Show completion popup for this specific message
        setShowCompletionForMessage(lastAIMessage.id);
      }
    }
  }, [progress, showCompletionForMessage, allMessages, sessionStartTime]);

  // Keep screen awake while recording
  useEffect(() => {
    if (isRecording) {
      activateKeepAwakeAsync()
        .catch(error => console.error('❌ Failed to activate keep awake:', error));
    } else {
      deactivateKeepAwake();
    }
  }, [isRecording]);

  // Cleanup keep awake on component unmount
  useEffect(() => {
    return () => {
      deactivateKeepAwake();
    };
  }, []);

  // Klavye yüksekliğini izle
  useEffect(() => {
    const keyboardWillShow = (event: any) => {
      setKeyboardHeight(event.endCoordinates.height);
    };

    const keyboardWillHide = () => {
      setKeyboardHeight(0);
    };

    const keyboardWillShowListener = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow',
      keyboardWillShow
    );
    const keyboardWillHideListener = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide',
      keyboardWillHide
    );

    return () => {
      keyboardWillShowListener.remove();
      keyboardWillHideListener.remove();
    };
  }, []);

  // Text change handlers for dynamic input
  const handleTextChange = (text: string) => {
    setChatInput(text);
    
    // Daha hassas hesaplama - kelime bazlı satır atlama
    const containerWidth = 362; // chatInputWrapper width
    const containerPadding = 16; // 8px left + 8px right padding
    const textInputPadding = 8; // 4px left + 4px right padding
    
    // İlk önce satır sayısını tahmini hesapla
    const estimatedLines = Math.max(1, text.split('\n').length);
    const isMultiLine = estimatedLines > 1 || text.length > 30; // Daha erken multi-line algılama
    const expandButtonSpace = isMultiLine ? 36 : 0; // Expand butonu için alan
    const availableWidth = containerWidth - containerPadding - textInputPadding - expandButtonSpace;
    
    // Font boyutuna göre karakter genişliği (fontSize: 15, fontWeight: 400)
    // Daha conservative hesaplama - kelimeler için fazladan margin
    const baseCharsPerLine = isMultiLine ? 36 : 42; // Multi-line'da daha az karakter
    const charsPerLine = baseCharsPerLine;
    
    // Satır hesaplama - kelime kırılması dahil
    const textLines = text.split('\n');
    let totalLines = 0;
    
    textLines.forEach(line => {
      if (line.length === 0) {
        totalLines += 1; // Boş satır
      } else {
        // Kelime bazlı hesaplama - uzun kelimelerin satır atlama riski için
        const words = line.split(' ');
        let currentLineLength = 0;
        let linesForThisTextLine = 1;
        
        words.forEach((word, index) => {
          const wordLength = word.length;
          const spaceNeeded = index > 0 ? 1 : 0; // Space before word (except first)
          
          // Eğer bu kelime mevcut satıra sığmayacaksa, yeni satır
          if (currentLineLength + spaceNeeded + wordLength > charsPerLine && currentLineLength > 0) {
            linesForThisTextLine++;
            currentLineLength = wordLength;
          } else {
            currentLineLength += spaceNeeded + wordLength;
          }
        });
        
        totalLines += linesForThisTextLine;
      }
    });
    
    // Satır sayısını kaydet
    setCurrentLineCount(totalLines);
    
    // Min/Max sınırları - expand durumuna göre
    const maxLines = isInputExpanded ? EXPANDED_MAX_LINES : MAX_LINES;
    const actualLines = Math.max(MIN_LINES, Math.min(maxLines, totalLines));
    
    // Yükseklik hesaplama
    const newInputHeight = actualLines * LINE_HEIGHT;
    
    // Container yüksekliği - gerçek layout'a göre optimize
    const topPadding = 12; // TextInput üst padding artırıldı
    const bottomPadding = 8;
    const buttonHeight = 32; // Voice/Send buton yüksekliği
    const buttonTopPadding = 8; // Button container padding top
    
    const totalContainerHeight = topPadding + newInputHeight + buttonTopPadding + buttonHeight + bottomPadding;
    const newContainerHeight = Math.max(CONTAINER_BASE_HEIGHT, totalContainerHeight);
    
    setInputHeight(newInputHeight);
    setContainerHeight(newContainerHeight);
  };

  const handleContentSizeChange = (event: any) => {
    const { height } = event.nativeEvent.contentSize;
    
    // Min/Max yükseklikleri hesapla
    const minHeight = MIN_LINES * LINE_HEIGHT; // 24px
    const maxHeight = MAX_LINES * LINE_HEIGHT; // 240px
    
    // Gerçek content yüksekliğini kullan ama LINE_HEIGHT'a yuvarla
    const rawHeight = Math.max(minHeight, Math.min(maxHeight, height));
    
    // En yakın LINE_HEIGHT katına yuvarla (24px'in katları)
    const roundedLines = Math.round(rawHeight / LINE_HEIGHT);
    const newInputHeight = Math.max(MIN_LINES, Math.min(MAX_LINES, roundedLines)) * LINE_HEIGHT;
    
    // Container yüksekliği - handleTextChange ile aynı hesaplama
    const topPadding = 12; // TextInput üst padding artırıldı
    const bottomPadding = 8;
    const buttonHeight = 32; // Voice/Send buton yüksekliği
    const buttonTopPadding = 8; // Button container padding top
    
    const totalContainerHeight = topPadding + newInputHeight + buttonTopPadding + buttonHeight + bottomPadding;
    const newContainerHeight = Math.max(CONTAINER_BASE_HEIGHT, totalContainerHeight);
    
    setInputHeight(newInputHeight);
    setContainerHeight(newContainerHeight);
  };

  // Ensure last lines remain visible when input grows to a new line - DISABLED to prevent auto-scroll
  useEffect(() => {
    // Disabled: This was causing unwanted auto-scroll when typing
    // Only scroll if user explicitly wants it, not automatically on input height change
    return;
  }, [inputHeight, containerHeight]);

  // Expand toggle function
  const handleExpandToggle = () => {
    setIsInputExpanded(!isInputExpanded);
    
    // Mevcut text'e göre yeniden hesapla
    setTimeout(() => {
      handleTextChange(chatInput);
    }, 0);
  };

  // Send message using current session ID
  const handleSendMessage = async () => {
    if (chatInput.trim().length === 0 || !currentSessionId) return;

    const messageContent = chatInput.trim();
    setChatInput('');
    
    // Reset input height and expand state
    setInputHeight(LINE_HEIGHT);
    setContainerHeight(CONTAINER_BASE_HEIGHT);
    setIsInputExpanded(false);
    setCurrentLineCount(1);
    
    // Set positioning flag
    hasUserScrolled.current = false;
    scrollToNewMessageRef.current = true; // This flag will trigger positioning

    console.log(`📤 Sending message to session: ${currentSessionId} (${isBreakoutSession ? 'breakout' : 'main'})`);

    // If showing starting state, persist it and clear the state
    if (showingStartingState && startingStateMessage) {
      setShowingStartingState(false);
      setStartingStateMessage(null);
      console.log('📌 Persisting starting state message due to user response');
    }

    // Track coaching session started for new main sessions
    if (!isBreakoutSession && allMessages.length === 0) {
      console.log('🎯 [COACHING] Starting main coaching session...', {
        sessionId: currentSessionId,
        sessionType: 'main-session',
        trigger: 'manual'
      });
      
      trackCoachingSessionStarted({
        session_id: currentSessionId,
        session_type: 'regular',
        trigger: 'manual',
      });
    }

    await sendMessage(messageContent, currentSessionId, {
      sessionType: 'default-session'
    });
  };

  const handleMicrophonePress = () => {
    // Start recording without losing keyboard focus
    const wasInputFocused = isChatInputFocused;
    startRecording();
    
    // Keep input focused if it was focused before
    if (wasInputFocused && textInputRef.current) {
      setTimeout(() => {
        textInputRef.current?.focus();
      }, 100);
    }
  };

  const handleRecordingCancel = () => {
    // Remember if input was focused before recording started
    const wasInputFocused = isChatInputFocused;
    cancelRecording();
    
    // Restore focus after canceling recording
    if (wasInputFocused && textInputRef.current) {
      setTimeout(() => {
        textInputRef.current?.focus();
      }, 100);
    }
  };

  const handleRecordingConfirm = () => {
    // Remember if input was focused before recording started
    const wasInputFocused = isChatInputFocused;
    stopRecordingAndTranscribe();
    
    // Restore focus after recording ends
    if (wasInputFocused && textInputRef.current) {
      setTimeout(() => {
        textInputRef.current?.focus();
      }, 200);
    }
  };


  // 7. Simplify handleScroll:
  const handleScroll = (event: any) => {
    const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent;
    const scrollY = contentOffset.y;
    
    // User scroll detection
    if (targetScrollPosition.current !== null) {
      const savedPosition = targetScrollPosition.current;
      const scrollDifference = Math.abs(scrollY - savedPosition);
      
      if (scrollDifference > 50) { // Larger threshold
        console.log('👆 User scrolled manually, clearing positioning');
        hasUserScrolled.current = true;
        targetScrollPosition.current = null;
      }
    }
    
    // Scroll to bottom button - show when content is scrollable and not at bottom
    const hasMessages = allMessages.length > 0;
    const lastMessage = hasMessages ? allMessages[allMessages.length - 1] : null;
    const isAIResponseComplete = !isLoading && lastMessage?.role === 'assistant';
    
    if (isAIResponseComplete) {
      const contentHeight = contentSize.height;
      const screenHeight = layoutMeasurement.height;
      const distanceFromBottom = contentHeight - screenHeight - scrollY;
      setShowScrollToBottom(distanceFromBottom > 200);
    } else {
      setShowScrollToBottom(false);
    }
  };

  const handleCompletionAction = async () => {
    console.log('User clicked End this session');
    console.log('📊 Session Stats:', completionStats);
    console.log('🎯 Parsed Coaching Data:', parsedCoachingData);
    
    if (parsedCoachingData) {
      parsedCoachingData.components.forEach((component, index) => {
        console.log(`  ${index + 1}. ${component.type.toUpperCase()}:`, component.props);
      });
    }
    
    // Create goal breakout session and link to journal entry
    if (currentSessionId && firebaseUser) {
      try {
        console.log('🎯 Creating goal breakout session for completed coaching session:', currentSessionId);
        await createGoalBreakoutSession(currentSessionId);
      } catch (error) {
        console.error('❌ Failed to create goal breakout session:', error);
      }
    }
    
    // Navigate to compass story for coaching completion immediately
    (navigation as any).navigate('CompassStory', { 
      fromCoaching: true,
      sessionId: currentSessionId || undefined,
      parsedCoachingData: parsedCoachingData || undefined
    });
    setShowCompletionForMessage(null);
    
    // Trigger insight extraction in background if we have a session ID
    if (currentSessionId) {
      console.log('🧠 Starting insight extraction for session:', currentSessionId);
      triggerInsightExtraction(currentSessionId); // Don't await - run in background
    }
  };

  // Function to trigger insight extraction
  const triggerInsightExtraction = async (sessionId: string) => {
    try {
      const token = await getToken();
      if (!token) {
        console.error('❌ No auth token available for insight extraction');
        return;
      }

      console.log('📤 Calling insight extraction API...', {
        endpoint: `${process.env.EXPO_PUBLIC_API_URL}api/coaching/insightExtractor`,
        sessionId: sessionId,
        hasToken: !!token
      });

      const response = await fetch(`${process.env.EXPO_PUBLIC_API_URL}api/coaching/insightExtractor`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          sessionId: sessionId
        }),
      });

      console.log('📥 Insight extraction API response:', {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok
      });

      if (response.ok) {
        const result = await response.json();
        console.log('✅ Insight extraction successful:', result);
      } else {
        const errorText = await response.text();
        console.error('❌ Insight extraction failed:', {
          status: response.status,
          statusText: response.statusText,
          errorText: errorText
        });
      }
    } catch (error) {
      console.error('❌ Error calling insight extraction API:', error);
    }
  };

  // Function to create goal breakout session and link to journal entry
  const createGoalBreakoutSession = async (completedSessionId: string) => {
    try {
      const token = await getToken();
      if (!token) {
        console.error('❌ No auth token available for goal breakout session creation');
        return;
      }

      // Generate new session ID for the goal breakout session
      const goalBreakoutSessionId = Crypto.randomUUID();
      
      console.log('🎯 Creating goal breakout session...', {
        completedSessionId,
        goalBreakoutSessionId,
        userId: firebaseUser?.uid
      });

      // Create the goal breakout session via API
      const response = await fetch(`${process.env.EXPO_PUBLIC_API_URL}api/coaching/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          sessionId: goalBreakoutSessionId,
          sessionType: 'default-session',
          parentSessionId: completedSessionId, // Link to the completed coaching session
          messages: [
            {
              id: Crypto.randomUUID(),
              role: 'assistant',
              content: 'Based on our coaching session, I\'ve created a personalized goal breakout plan for you. Let\'s dive deeper into your action steps and create a concrete plan to move forward.',
              timestamp: new Date().toISOString()
            }
          ],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to create goal breakout session: ${response.status}`);
      }

      const sessionResult = await response.json();
      console.log('✅ Goal breakout session created:', sessionResult);

      // Create a new journal entry linked to this goal breakout session
      const entryId = Crypto.randomUUID();
      const newEntry = {
        uid: firebaseUser!.uid,
        content: '', // Empty content - user will fill this in
        timestamp: serverTimestamp(),
        lastUpdated: serverTimestamp(),
        linkedCoachingSessionId: goalBreakoutSessionId, // Link to the goal breakout session
        title: `Goal Breakout - ${new Date().toLocaleDateString()}`
      };

      const docRef = doc(db, 'journal_entries', entryId);
      await setDoc(docRef, newEntry);

      console.log('✅ Journal entry created and linked to goal breakout session:', {
        entryId,
        linkedSessionId: goalBreakoutSessionId
      });

      // Track goal breakout session creation
      trackEntryCreated({
        entry_id: entryId,
      });

    } catch (error) {
      console.error('❌ Error creating goal breakout session:', error);
      throw error;
    }
  };

  return (
    <View style={[styles.container, { backgroundColor: colors.background }]}>
      <KeyboardAvoidingView
        style={styles.keyboardAvoidingView}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
      >
        {/* Header */}
        <View style={[styles.chatHeader, { backgroundColor: colors.background, paddingTop: insets.top + 25, borderColor: `${colors.tint}12` }]}>
          <Text style={[styles.chatHeaderText, { color: colors.text }]}>
            {isBreakoutSession ? 'Breakout Session' : 'Coach'}
          </Text>
        </View>

        {/* Messages */}
        <View style={styles.messagesContainer}>
          <ScrollView
            ref={scrollViewRef}
            style={styles.messagesList}
            contentContainerStyle={[
              styles.messagesContent, 
              { 
                minHeight: scrollLimits.minContentHeight,
                paddingBottom: dynamicBottomPadding
              }
            ]}
            scrollEventThrottle={16}
            onScroll={(event) => {
              // Call existing handleScroll function
              handleScroll(event);
              
              // Update content height
              const { contentSize } = event.nativeEvent;
              setContentHeight(contentSize.height);
            }}
            onLayout={(event) => {
              // ScrollView height'ını kaydet
              const { height } = event.nativeEvent.layout;
              setScrollViewHeight(height);
            }}
            showsVerticalScrollIndicator={false}
            keyboardShouldPersistTaps="always"
            keyboardDismissMode="interactive"
            bounces={true}
            overScrollMode="never"
            refreshControl={
              <RefreshControl
                refreshing={isLoadingMore}
                onRefresh={loadMoreMessages}
                enabled={hasMoreMessages}
                tintColor={`${colors.text}40`}
                colors={[`${colors.text}40`]}
                progressBackgroundColor="transparent"
                title=""
              />
            }
            // Scroll limiti ekle
            onScrollEndDrag={(event) => {
              const { contentOffset } = event.nativeEvent;
              
              // Eğer maksimum scroll limitini aşmışsa, geri getir
              if (contentOffset.y > scrollLimits.maxScrollDistance) {
                scrollViewRef.current?.scrollTo({
                  y: scrollLimits.maxScrollDistance,
                  animated: true
                });
              }
            }}
            // Momentum scroll sonrası da kontrol et
            onMomentumScrollEnd={(event) => {
              const { contentOffset } = event.nativeEvent;
              
              if (contentOffset.y > scrollLimits.maxScrollDistance) {
                scrollViewRef.current?.scrollTo({
                  y: scrollLimits.maxScrollDistance,
                  animated: true
                });
              }
            }}
          >

            {/* Loading existing session */}
            {loadingExistingSession && (
              <View style={[styles.messageContainer, styles.aiMessageContainer]}>
                <AnimatedTypingIndicator colorScheme={colorScheme} />
                <Text style={[styles.messageText, { color: `${colors.text}60`, marginLeft: 8 }]}>
                  Loading session...
                </Text>
              </View>
            )}

            {/* Render all messages (Firestore + local + starting state) */}
            {allMessages.map((message) => (
              <View
                key={message.id}
                ref={(ref) => {
                  messageRefs.current[message.id] = ref;
                }}
                style={[
                  styles.messageContainer,
                  message.role === 'user' ? styles.userMessageContainer : styles.aiMessageContainer
                ]}
              >
                                 <View>
                   <Text
                     style={[
                       styles.messageText,
                       message.role === 'user'
                         ? { color: `${colors.text}99` }
                         : { color: colors.text }
                     ]}
                   >
                     {getDisplayContent(message.content)}
                   </Text>

                   {/* Render coaching cards for AI messages */}
                   {message.role === 'assistant' && (() => {
                     const coachingCards = parseCoachingCards(message.content);
                     if (coachingCards.length > 0) {
                       return (
                         <View style={{ marginTop: 8, marginBottom: 16 }}>
                           {coachingCards.map((card, index) => renderCoachingCard(card.type, card.props, index))}
                         </View>
                       );
                     }
                     return null;
                   })()}
                 </View>

                 {/* Completion Popup - appears on final message when progress reaches 100% */}
                 {message.role === 'assistant' && showCompletionForMessage === message.id && (
                   <View style={[
                     styles.aiPopup,
                     {
                       backgroundColor: colorScheme === 'dark' ? '#2A2A2A' : '#FFFFFF',
                       borderColor: colorScheme === 'dark' ? '#333' : '#0000001A',
                     }
                   ]}>
                     <View style={styles.aiPopupContent}>
                       <Text style={[styles.aiPopupHeader, { color: colors.text }]}>
                         Session complete!
                       </Text>
                       <Text style={[styles.aiPopupText, { color: `${colors.text}80` }]}>
                         Great work on your coaching session.
                       </Text>
                       
                       <Text style={[styles.aiPopupText, { color: `${colors.text}66`, fontSize: 13, marginTop: 4 }]}>
                         {completionStats.minutes} min • {completionStats.words} words • {completionStats.keyInsights} key insights
                       </Text>

                       <View style={styles.aiPopupButtons}>
                         <Button
                           variant="primary"
                           size="sm"
                           onPress={handleCompletionAction}
                           style={{ flex: 1 }}
                         >
                           View your compass
                         </Button>
                       </View>
                     </View>
                   </View>
                 )}
               </View>
             ))}
            {shouldShowLoadingIndicator && (
              <View style={[
                styles.messageContainer, 
                styles.aiMessageContainer,
                styles.loadingMessageContainer
              ]}>
                <AnimatedTypingIndicator colorScheme={colorScheme} />
              </View>
            )}
          </ScrollView>
          
          {/* Scroll to bottom button */}
          {showScrollToBottom && (
            <TouchableOpacity
              style={[
                styles.scrollToBottomButton,
                {
                  backgroundColor: colorScheme === 'dark' ? '#333333' : '#FFFFFF',
                  bottom: keyboardHeight > 0 
                    ? keyboardHeight + containerHeight - 300  // Keyboard + input height + margin
                    : 280 + containerHeight - 90, // Normal position + input growth
                }
              ]}
              onPress={handleScrollToBottom}
            >
              <ArrowDown size={20} color={colors.text} />
            </TouchableOpacity>
          )}
        </View>

        {/* Suggestion Buttons - only show when input is empty */}
        {chatInput.trim().length === 0 && keyboardHeight === 0 && (
          <View style={styles.suggestionContainer}>
            <ScrollView 
              horizontal 
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.suggestionScrollContent}
              style={styles.suggestionScrollView}
              nestedScrollEnabled={true}
              directionalLockEnabled={true}
              alwaysBounceVertical={false}
              bounces={false}
            >
              <TouchableOpacity 
                style={styles.suggestionButton}
                onPress={() => setChatInput('Start Custom Meditation')}
              >
                <Text style={styles.suggestionButtonText}>Start Custom{'\n'}Meditation</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.suggestionButton}
                onPress={() => setChatInput('Ask me hard questions')}
              >
                <Text style={styles.suggestionButtonText}>Ask me hard{'\n'}questions</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.suggestionButton}
                onPress={() => setChatInput('Help me find my goal')}
              >
                <Text style={styles.suggestionButtonText}>Help me find{'\n'}my goal</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.suggestionButton}
                onPress={() => setChatInput('Work through uncertainty')}
              >
                <Text style={styles.suggestionButtonText}>Work through{'\n'}uncertainty</Text>
              </TouchableOpacity>
            </ScrollView>
          </View>
        )}

        {/* Input */}
        <View style={[styles.chatInputContainer, { 
          bottom: keyboardHeight > 0 ? keyboardHeight - 10 : 80, // If keyboard open: slightly overlapping, otherwise 80px above navbar
          paddingBottom: Math.max(insets.bottom, 0)
        }]} pointerEvents="box-none">
          <View
            pointerEvents="auto"
            style={[
            styles.chatInputWrapper,
            {
                backgroundColor: colorScheme === 'dark' ? '#2A2A2A' : '#FFFFFF',
                borderColor: colorScheme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : '#00000012',
                height: containerHeight // Dinamik yükseklik
              }
            ]}
          >
            {/* Expand Button - sadece 1 satırdan fazlayken görünür */}
            {currentLineCount > 1 && (
              <TouchableOpacity
                style={[styles.expandButton, {
                  backgroundColor: colorScheme === 'dark' ? '#404040' : '#F0F0F0',
                }]}
                onPress={handleExpandToggle}
              >
                <IconSymbol
                  name={isInputExpanded ? "arrow.down.right.and.arrow.up.left" : "arrow.up.left.and.arrow.down.right"}
                  size={14}
                  color={colorScheme === 'dark' ? '#FFFFFF' : '#666666'}
                />
              </TouchableOpacity>
            )}
            
            {!isRecording && !isTranscribing ? (
              /* Main Input Container - vertical layout */
              <View style={styles.mainInputContainer}>
                {/* TextInput at the top */}
              <TextInput
                ref={textInputRef}
                style={[
                  styles.chatInput,
                    { 
                      color: colors.text,
                      height: inputHeight, // Dinamik yükseklik
                      width: currentLineCount > 1 ? '92%' : '100%', // Expand butonu için alan bırak (~28px az)
                      paddingRight: currentLineCount > 1 ? 32 : 4, // Expand butonu için sağ padding
                    }
                ]}
                value={chatInput}
                  onChangeText={handleTextChange} // Ana controller
                  onContentSizeChange={undefined} // Devre dışı - sadece handleTextChange kullan
                onFocus={() => setIsChatInputFocused(true)}
                onBlur={() => setIsChatInputFocused(false)}
                  placeholder="Write how you think..."
                  placeholderTextColor={colorScheme === 'dark' ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 0, 0, 0.50)'}
                multiline
                maxLength={500}
                returnKeyType='default'
                onSubmitEditing={handleSendMessage}
                cursorColor={colors.tint}
                  scrollEnabled={inputHeight >= (isInputExpanded ? EXPANDED_MAX_LINES : MAX_LINES) * LINE_HEIGHT} // Maksimum yükseklikte scroll aktif
                  textBreakStrategy="balanced" // Kelime kırma stratejisi
                />
                
                {/* Button Container at the bottom - Voice + Send buttons side by side */}
                <View style={styles.buttonContainer}>
                  {chatInput.trim().length > 0 ? (
                <TouchableOpacity
                      style={[styles.microphoneButtonRound, { 
                        backgroundColor: colorScheme === 'dark' ? '#404040' : '#E6E6E6' 
                      }]}
                      onPress={handleMicrophonePress}
                    >
                      <Mic
                        size={18}
                        color={colorScheme === 'dark' ? '#AAAAAA' : '#737373'}
                        strokeWidth={1.5}
                  />
                </TouchableOpacity>
                  ) : (
                  <TouchableOpacity
                      style={[styles.voiceButton, { 
                        backgroundColor: colorScheme === 'dark' ? '#404040' : '#E6E6E6' 
                      }]}
                      onPress={handleMicrophonePress}
                    >
                      <Text style={[styles.voiceButtonText, { 
                        color: colorScheme === 'dark' ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.50)' 
                      }]}>
                        Voice
                      </Text>
                      <IconSymbol
                        name="waveform"
                        size={12}
                        color={colorScheme === 'dark' ? '#AAAAAA' : '#737373'}
                    />
                  </TouchableOpacity>
            )}

                  <TouchableOpacity
                    style={[styles.sendButtonRound, { 
                      backgroundColor: colorScheme === 'dark' ? '#FFFFFF' : '#000000',
                      shadowColor: '#000',
                      shadowOffset: { width: 0, height: 2 },
                      shadowOpacity: 0.2,
                      shadowRadius: 4,
                      elevation: 3,
                    }]}
                    onPress={chatInput.trim().length > 0 ? handleSendMessage : handleMicrophonePress}
                  >
                    {chatInput.trim().length > 0 ? (
                      <ArrowUp
                        size={18}
                        color={colorScheme === 'dark' ? '#000000' : '#FFFFFF'}
                        strokeWidth={1.5}
                      />
                    ) : (
                      <Mic
                        size={18}
                        color={colorScheme === 'dark' ? '#000000' : '#FFFFFF'}
                        strokeWidth={1.5}
                      />
                    )}
                  </TouchableOpacity>
                </View>
              </View>
            ) : isTranscribing ? (
              <View style={styles.transcribingContainer}>
                <SpinningAnimation colorScheme={colorScheme} />
              </View>
            ) : (
              /* Recording state */
              <View style={styles.recordingStateContainer}>
                    <TouchableOpacity
                  style={[styles.recordingButton, { backgroundColor: `${colors.text}20` }]}
                  onPress={handleRecordingCancel}
                    >
                  <X size={20} color={colors.text} />
                    </TouchableOpacity>
                
                <View style={styles.recordingCenterSection}>
                  <AudioLevelIndicator audioLevel={audioLevel} colorScheme={colorScheme} />
                </View>
                
                <View style={styles.recordingRightSection}>
                  <RecordingTimer startTime={recordingStartTime} colorScheme={colorScheme} />
                    <TouchableOpacity
                    style={[styles.recordingButton, { backgroundColor: colors.text }]}
                    onPress={handleRecordingConfirm}
                  >
                    <Check size={20} color={colors.background} />
                    </TouchableOpacity>
                  </View>
              </View>
            )}
          </View>
        </View>
      </KeyboardAvoidingView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  chatHeader: {
    paddingHorizontal: 20,
    paddingBottom: 16,
    borderBottomLeftRadius: 25,
    borderBottomRightRadius: 25,
    alignItems: 'flex-start',
    borderBottomWidth: 1,
    borderLeftWidth: 1,
    borderRightWidth: 1,
    zIndex: 10,
  },
  chatHeaderText: {
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'left',
  },
  messagesContainer: {
    flex: 1,
    paddingHorizontal: 20,
    paddingBottom: 4,
  },
  messagesList: {
    flex: 1,
    paddingTop: 12,
    zIndex: 0,
    overflow: 'visible',
    backgroundColor: 'transparent'
  },
  messagesContent: {
    flexGrow: 1,
  },
  messageContainer: {
    marginBottom: 16,
    paddingVertical: 6,
  },
  userMessageContainer: {
    alignItems: 'flex-end',
  },
  aiMessageContainer: {
    alignItems: 'flex-start',
  },
  messageText: {
    fontSize: 16,
    fontWeight: '400',
    lineHeight: 22,
  },
  typingIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 8,
    paddingHorizontal: 4,
    minHeight: 32, // Sabit minimum height
  },
  
  // Loading state'te message container için
  loadingMessageContainer: {
    minHeight: 60, // Loading indicator için sabit alan
    justifyContent: 'center',
  },
  typingDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  chatInputContainer: {
    paddingHorizontal: 20,
    paddingBottom: 0,
    paddingTop: 0,
    position: 'absolute',
    bottom: 0, // Navbar'dan 40px yukarıda
    left: 0,
    right: 0,
    justifyContent: 'flex-end', // İçeriği alt kısma hizala (yukarı genişleme için)
    zIndex: 1000, // Base z-index
  },
  chatInputWrapper: {
    alignSelf: 'center',
    width: 362,
    backgroundColor: '#FFFFFF',
    borderRadius: 24,
    borderTopWidth: 0.5,
    borderRightWidth: 0.5,
    borderBottomWidth: 0,
    borderLeftWidth: 0.5,
    borderColor: '#00000012',
    padding: 8,
    gap: 10,
    flexDirection: 'row',
    alignItems: 'flex-end', // Butonları alt kısma hizala
    justifyContent: 'flex-start',
    overflow: 'visible',
    opacity: 1,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 0,
    },
    shadowOpacity: 0.4,
    shadowRadius: 10,
    elevation: 15,
  },
  mainInputContainer: {
    flex: 1,
    paddingHorizontal: 8,
    paddingTop: 12, // Üst padding artırıldı
    paddingBottom: 8,
    flexDirection: 'column',
    justifyContent: 'space-between',
    alignItems: 'stretch',
    width: '100%',
  },
  chatInput: {
    fontSize: 15,
    fontWeight: '400',
    lineHeight: 24,
    minHeight: 24, // Minimum yükseklik
    paddingVertical: 0,
    paddingHorizontal: 4,
    backgroundColor: 'transparent',
    textAlignVertical: 'top',
  },
  buttonContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end',
    gap: 6,
    paddingTop: 8,
  },
  voiceButton: {
    height: 32,
    paddingHorizontal: 8,
    borderRadius: 100,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 4,
  },
  voiceButtonText: {
    fontSize: 11,
    fontWeight: '600',
    lineHeight: 16,
  },
  microphoneButtonRound: {
    width: 32,
    height: 32,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  sendButtonRound: {
    width: 32,
    height: 32,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  sendButtonIcon: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  transcribingContainer: {
    alignItems: 'flex-start',
    paddingVertical: 8,
  },
  recordingStateContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    paddingHorizontal: 8,
    paddingVertical: 8,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.02)',
    borderRadius: 24,
  },
  sendButton: {
    width: 34,
    height: 34,
    borderRadius: 17,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.15,
    shadowRadius: 2,
    elevation: 2,
  },
  microphoneButton: {
    width: 34,
    height: 34,
    borderRadius: 17,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.15,
    shadowRadius: 2,
    elevation: 2,
  },
  recordingCenterSection: {
    flex: 1,
    alignItems: 'flex-start',
    paddingLeft: 10,
  },
  recordingRightSection: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  recordingButton: {
    width: 34,
    height: 34,
    borderRadius: 17,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.15,
    shadowRadius: 2,
    elevation: 2,
  },
  loadingSpinner: {
    alignItems: 'center',
    justifyContent: 'center',
    height: 20,
    width: 20,
  },
  spinner: {
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#E5E5E5',
    borderTopColor: '#333333',
  },
  audioLevelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  audioLevelDot: {
    width: 6,
    height: 6,
    borderRadius: 3,
  },
  recordingTimer: {
    fontSize: 14,
    fontWeight: '500',
  },
  aiPopup: {
    width: '105%',
    alignSelf: 'center',
    gap: 4,
    borderRadius: 16,
    marginTop: 12,
    borderWidth: 1,
    borderColor: '#0000001A',
  },
  aiPopupContent: {
    paddingTop: 16,
    paddingRight: 16,
    paddingBottom: 8,
    paddingLeft: 16,
    gap: 4,
  },
  aiPopupHeader: {
    fontSize: 14,
    fontWeight: '500',
    lineHeight: 16,
  },
  aiPopupText: {
    fontSize: 14,
    fontWeight: '400',
    lineHeight: 16,
  },
  aiPopupButtons: {
    flexDirection: 'row',
    gap: 8,
    paddingVertical: 8,
  },
  scrollToBottomButton: {
    position: 'absolute',
    right: 20,
    width: 28,
    height: 28,
    borderRadius: 14,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 0, // Border kaldır, sadece ok
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
    zIndex: 999, // Input'tan düşük z-index
  },
  suggestionContainer: {
    position: 'absolute',
    bottom: 210, // Input'un üstünde
    left: 0,
    right: 0,
    paddingHorizontal: 20,
    paddingBottom: 12,
    zIndex: 1001, // Input'tan daha yüksek
  },
  suggestionScrollView: {
    flexGrow: 0,
  },
  suggestionScrollContent: {
    paddingHorizontal: 0,
    gap: 8,
    alignItems: 'center',
  },
  suggestionButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#F2F2F2',
    borderRadius: 12,
    marginRight: 8,
    justifyContent: 'center',
    alignItems: 'center',
    minWidth: 80,
  },
  suggestionButtonText: {
    color: 'rgba(0, 0, 0, 0.60)',
    fontSize: 12,
    fontWeight: '500',
    lineHeight: 16,
    textAlign: 'center',
  },
  expandButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    width: 28,
    height: 28,
    borderRadius: 14,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
    zIndex: 10,
  },
}); 